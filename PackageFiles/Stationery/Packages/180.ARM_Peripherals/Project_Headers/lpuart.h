/****************************************************************************************************//**
 * @file     uart.h
 *
 * @brief    Abstracion layer for UART interface
 *
 * @version  V0.0
 * @date     2015/06
 *
 *******************************************************************************************************/

#ifndef INCLUDE_USBDM_LPUART_H_
#define INCLUDE_USBDM_LPUART_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "derivative.h"
#include "hardware.h"
#include "mcg.h"

namespace USBDM {

/**
 * @addtogroup LPUART_Group Universal Asynchronous Receiver/Transmitter
 * @brief C++ Class allowing access to UART interface
 * @{
 */

/**
 * Virtual Base class for LPUART interface
 */
class Lpuart {

protected:
   volatile LPUART_Type *uart;            //!< UART hardware instance

   /**
    * Construct UART interface
    *
    * @param uart             Base address of UART hardware
    *
    */
   Lpuart(volatile LPUART_Type *uart) : uart(uart) {
   }

   /**
    * Set baud factor value for interface
    *
    * This is calculated from baud rate and LPUART clock frequency
    *
    * @param baudrate       - Interface speed in bits-per-second
    * @param clockFrequency - Frequency of LPUART clock
    */
   void setBaudRate(uint32_t baudrate, uint32_t clockFrequency) {
      static constexpr uint32_t overSample = 16;

      // Disable UART before changing registers
      uart->CTRL &= ~(LPUART_CTRL_TE_MASK | LPUART_CTRL_RE_MASK);

      // Calculate UART clock setting
      int scaledBaudValue = clockFrequency/(baudrate*overSample);

      // Set Baud rate register
      uart->BAUD = (uart->BAUD&~(LPUART_BAUD_SBR_MASK|LPUART_BAUD_OSR_MASK))|
            LPUART_BAUD_SBR(scaledBaudValue)|LPUART_BAUD_OSR(overSample-1);

#if USE_IRQ
      // Enable UART Tx & Rx - with Rx IRQ
      uart->CTRL  = LPUART_CTRL_TE_MASK|LPUART_CTRL_RE_MASK|LPUART_CTRL_RIE_MASK;
      uart->CTRL |= LPUART_CTRL_TE_MASK|LPUART_CTRL_RE_MASK|LPUART_CTRL_RIE_MASK;
#else
      // Enable UART Tx & Rx
      uart->CTRL |= LPUART_CTRL_TE_MASK|LPUART_CTRL_RE_MASK;
#endif
   }

   /**
    * Set baud factor value for interface
    *
    * This is calculated from baud rate and LPUART clock frequency
    *
    * @param baudrate       - Interface speed in bits-per-second
    */
   virtual void setBaudRate(unsigned baudrate) = 0;

public:
   /**
    * Transmit message
    *
    * @param data     Data to transmit
    * @param size     Size of transmission data
    */
   void transmit(const uint8_t data[], uint16_t size) {
      while (size-->0) {
         tx(*data++);
      }
   }

   /**
    * Receive message
    *
    * @param data     Data buffer for reception
    * @param size     Size of data to receive
    */
   void receive(uint8_t data[], uint16_t size) {
      while (size-->0) {
         *data++ = rx();
      }
   }
   /*
    * Transmits a single character over the UART (blocking)
    *
    * @param ch - character to send
    */
   void tx(int ch) {
      while ((uart->STAT & LPUART_STAT_TDRE_MASK) == 0) {
         // Wait for Tx buffer empty
         __asm__("nop");
      }
      uart->DATA = ch;
   }
   /*
    * Transmits a '\0' terminated string over the UART (blocking)
    *
    * @param s - String to send
    */
   void tx(const char *s) {
      while (*s != '\0') {
         tx(*s++);
      }
   }
   /*
    * Receives a single character over the UART (blocking)
    *
    * @return - character received
    */
   int rx(void) {
      uint8_t status;
      // Wait for Rx buffer full
      do {
         status = uart->STAT;
         // Clear & ignore pending errors
         if ((status & (LPUART_STAT_FE_MASK|LPUART_STAT_NF_MASK|LPUART_STAT_OR_MASK)) != 0) {
            uart->STAT = LPUART_STAT_FE_MASK|LPUART_STAT_NF_MASK|LPUART_STAT_OR_MASK;
         }
      }  while ((status & LPUART_STAT_RDRF_MASK) == 0);
      int ch = uart->DATA;
      if (ch == '\r') {
         ch = '\n';
      }
      return ch;
   }
};

/**
 * @brief Template class representing an UART interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Lpuart_T *lpuart0 = new USBDM::Lpuart_T<Uart1Info>(DEFAULT_BAUD_RATE);
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     lpuart0->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     lpuart0->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
template<class Info> class Lpuart_T : public Lpuart {
public:
   static class Lpuart *thisPtr;

public:
   /**
    * Construct LPUART interface
    *
    * @param baudrate         Interface speed in bits-per-second
    * @param clockFrequency   Frequency of LPUART clock
    */
   Lpuart_T(unsigned baudrate) : Lpuart(Info::lpuart) {
      // Enable clock to UART interface
      *Info::clockReg |= Info::clockMask;

      // Configure pins
      Info::initPCRs();
      setBaudRate(baudrate);
   }

   /**
    * Set baud factor value for interface
    *
    * This is calculated from baud rate and LPUART clock frequency
    *
    * @param baudrate       - Interface speed in bits-per-second
    */
   void setBaudRate(unsigned baudrate) {
      Lpuart::setBaudRate(baudrate, Info::getClockFrequency());
   }
};

#ifdef USBDM_LPUART0_IS_DEFINED
/**
 * @brief Class representing LPUART0 interface
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  Lpuart *uart = new USBDM::Lpuart();
 *
 *  // Transmit data
 *  const uint8_t txDataBuffer[] = {0x11, 0x22, 0x33, 0x44};
 *
 *  // Receive buffer
 *  uint8_t rxDataBuffer[5];
 *
 *  for(;;) {
 *     // Transmit block
 *     uart->transmit(txDataBuffer, sizeof(txDataBuffer));
 *
 *     // Receive block
 *     uart->receive((rxDataBuffer, sizeof(rxDataBuffer));
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing LPUART hardware
 */
class Lpuart0 : public Lpuart_T<Lpuart0Info> {
public:
   Lpuart0(unsigned baud=DEFAULT_BAUD_RATE) : Lpuart_T(baud) {
   }
};
#endif

/**
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_LPUART_H_ */
