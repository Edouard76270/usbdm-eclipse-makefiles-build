/*
 * tsi.h
 *
 *  Created on: 25/10/2013
 *      Author: podonoghue
 */

#ifndef TSI_H_
#define TSI_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "hardware.h"

namespace USBDM {

/**
 * Type definition for TSI interrupt call back
 *
 *  @param timeSinceEpoch - Time since the epoch in seconds
 */
typedef void (*TSICallbackFunction)();

template <class Info>
class TsiBase_T {

protected:
   static constexpr volatile TSI_Type *tsi      = Info::tsi;
   static constexpr volatile uint32_t *clockReg = Info::clockReg;

public:
   /**
    * Initialise TSI to default settings\n
    * Configures all TSI pins
    */
   static void initialise() {
      clockReg |= Info::clockMask;
      __DMB();

      Info::initPCRs();

      tsi->GENCS     = Info::tsi_gencs;
      tsi->SCANC     = Info::tsi_scanc;
      tsi->THRESHOLD = Info::tsi_threshold;
      tsi->PEN       = Info::tsi_pen;
   }
};

/**
 * Template class to provide TSI callback
 */
template<class Info>
class TsiIrq_T : public TsiBase_T<Info> {

protected:
   /** Callback function for ISR */
   static TSICallbackFunction callback;

public:
   /**
    * IRQ handler
    */
   static void irqHandler(void) {
      if (callback != 0) {
         callback();
      }
      TsiBase_T<Info>::tsi->GENCS  &= Info::tsi_gencs|TSI_GENCS_TSIIE_MASK;
   }

   /**
    * Set Callback function
    *
    *   @param theCallback - Callback function to be executed on TSI alarm interrupt
    *   @param time        - Time to set alarm for (time since the epoch in seconds)
    */
   static void setCallback(TSICallbackFunction theCallback, uint32_t time) {
      callback = theCallback;
      if (callback != NULL) {
         // Set alarm time
         TsiBase_T<Info>::tsi->TAR   = time;
         // Enable interrupts from TSI alarm
         TsiBase_T<Info>::tsi->GENCS   |= TSI_GENCS_TSIIE_MASK;
         NVIC_EnableIRQ(Info::irqNums[0]);
      }
      else {
         // Disable interrupts from TSI alarm
         TsiBase_T<Info>::tsi->GENCS   &= ~TSI_GENCS_TSIIE_MASK;
         NVIC_DisableIRQ(Info::irqNums[0]);
      }
   }
};

template<class Info> TSICallbackFunction TsiIrq_T<Info>::callback = 0;

#ifdef USBDM_TSI_IS_DEFINED
/**
 * Class representing TSI
 */
using Tsi = TsiIrq_T<TsiInfo>;

#endif

} // End namespace USBDM

#endif /* TSI_H_ */
